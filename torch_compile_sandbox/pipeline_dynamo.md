TorchDynamo Pipeline (torch.compile frontend)

Scope: bytecode transform -> FX graph capture -> backend handoff

High-level order
- Entry: `torch.compile(...)` wraps user fn with a Dynamo backend wrapper. Ref: torch/__init__.py:2466–2603.
- Eval-frame context sets custom frame handler. Ref: torch/_dynamo/eval_frame.py:56–66, 919–980, 1159–1198.
- When a Python frame runs, `convert_frame._compile` orchestrates capture and bytecode regeneration. Ref: torch/_dynamo/convert_frame.py:1076–1120.
- Inside `_compile_inner`, Dynamo logs original bytecode, then calls `compile_frame(...)`. Ref: torch/_dynamo/convert_frame.py:1128–1180.
- `compile_frame` uses `transform_code_object` with `trace_frame` callback to symbolically execute and produce an FX graph. Ref: torch/_dynamo/convert_frame.py:976–1041, 1001–1024.
- After tracing, Dynamo regenerates modified bytecode and performs post-passes: `remove_dead_code` then `remove_pointless_jumps`. Ref: torch/_dynamo/convert_frame.py:820–836, 830; torch/_dynamo/bytecode_analysis.py:63–141.
- Guards are built and attached to the resulting code object. Ref: torch/_dynamo/convert_frame.py:1253–1276.
- Backend handoff: `OutputGraph.call_user_compiler(gm, example_inputs)` invokes the chosen backend (Inductor by default). Ref: torch/_dynamo/output_graph.py:2053–2068, 2089–2101; torch/__init__.py:2377–2381.

IRs and what changes
- Python bytecode (original): logged at convert_frame.py:1144–1150.
- Python bytecode (Dynamo-modified): logged at convert_frame.py:1186–1192.
- FX Graph (ATen/Prims level) built by InstructionTranslator (symbolic_convert.py) via `trace_frame`. Entry: torch/_dynamo/convert_frame.py:755–806, 1006–1024. Instruction translator classes live in torch/_dynamo/symbolic_convert.py.

Key components and lines
- Eval frame hooks and `optimize`: torch/_dynamo/eval_frame.py
  - Class `OptimizedModule`: 340–519
  - `optimize(...)` decorator/context: 1159–1198
- Frame conversion: torch/_dynamo/convert_frame.py
  - `_compile(...)` entry: 1076–1120
  - `_compile_inner(...)`: 1128–1219 (bytecode logging), 1211–1231 (code consistency checks)
  - `compile_frame(...)`: 976–1041
  - `trace_frame(...)`: 755–806 (sets up InstructionTranslator), returns DynamoTracerOutput
  - Post-transform bytecode passes: 820–836; definitions at torch/_dynamo/bytecode_analysis.py:63–141
- Backend call boundary: torch/_dynamo/output_graph.py
  - `call_user_compiler(...)`: 2053–2101 (wraps backend, e.g., Inductor `compile_fx`)
- torch.compile registration: torch/__init__.py
  - Inductor backend wrapper `__call__`: 2377–2381

What the passes do
- remove_dead_code (bytecode): strips unreachable instructions produced during rewrite. Ref: torch/_dynamo/bytecode_analysis.py:63–108
- remove_pointless_jumps (bytecode): simplifies control flow (e.g., jumps to next). Ref: torch/_dynamo/bytecode_analysis.py:109–141
- FX capture: translates Python ops into an FX Graph with ATen/Prims ops, tracking guards, sources, and meta. Ref: convert_frame.py:755–806; symbolic_convert.py (class InstructionTranslator).

Experiment quickly
- Script: scripts/run_dynamo_bytecode_trace.py
  - Prints disassembly of original vs. Dynamo-generated bytecode
  - Dumps captured FX Graph
  - Lets you switch backend (e.g., `--backend eager`) to isolate Dynamo

