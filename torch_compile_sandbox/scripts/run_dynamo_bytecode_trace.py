#!/usr/bin/env python3
import argparse
import dis
import textwrap
import torch

from torch._dynamo import convert_frame, eval_frame


def demo_fn(x: torch.Tensor) -> torch.Tensor:
    # Tiny demo that exercises a couple of ops
    return (x.sin() + x.cos()).relu()


def main():
    p = argparse.ArgumentParser(description="Trace Dynamo bytecode and FX capture")
    p.add_argument("--backend", default="eager", help="Backend to compile to (eager or inductor)")
    p.add_argument("--fullgraph", action="store_true", help="Use fullgraph=True")
    p.add_argument("--dtype", default="float32")
    p.add_argument("--shape", default="16,16", help="Comma-separated shape, e.g. 16,16")
    args = p.parse_args()

    shape = tuple(int(s) for s in args.shape.split(","))
    dtype = getattr(torch, args.dtype)

    # Register a bytecode hook to dump the rewritten frame's bytecode
    def bytecode_hook(orig_code, new_code):
        print("=== Original bytecode ===")
        print("function:", orig_code.co_name, "@", orig_code.co_filename, ":", orig_code.co_firstlineno)
        dis.dis(orig_code)
        print("\n=== Dynamo-generated bytecode ===")
        print("function:", new_code.co_name, "@", new_code.co_filename, ":", new_code.co_firstlineno)
        dis.dis(new_code)
        return None  # keep default new_code

    rm_handle = convert_frame.register_bytecode_hook(bytecode_hook)

    opt = torch.compile(backend=args.backend, fullgraph=args.fullgraph)

    x = torch.randn(*shape, dtype=dtype)
    compiled = opt(demo_fn)
    out = compiled(x)
    print("\n=== Output summary ===")
    print("shape:", tuple(out.shape), "dtype:", out.dtype)

    # Also dump FX when available via eval_frame utilities
    try:
        from torch._dynamo.testing import collect_graphs

        graphs = []
        compiled_fx = collect_graphs(graphs)(demo_fn)
        compiled_fx(x)
        if graphs:
            gm = graphs[0]
            print("\n=== Captured FX graph (readable) ===")
            print(gm.print_readable(print_output=False))
    finally:
        rm_handle.remove()


if __name__ == "__main__":
    main()

